<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ FSM Blueprint Editor - Standalone</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }
        
        .toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: linear-gradient(135deg, #1e1e1e, #2d2d30);
            border-bottom: 3px solid #0078d4;
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
            gap: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        
        .toolbar h1 {
            margin: 0;
            font-size: 20px;
            background: linear-gradient(45deg, #0078d4, #00bcf2);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }
        
        .toolbar button {
            background: linear-gradient(45deg, #0078d4, #005a9e);
            border: none;
            color: white;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .toolbar button:hover {
            background: linear-gradient(45deg, #106ebe, #0078d4);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,120,212,0.4);
        }
        
        .toolbar button.special {
            background: linear-gradient(45deg, #44ff44, #2d8f2d);
        }
        
        .toolbar button.special:hover {
            background: linear-gradient(45deg, #55ff55, #3d9f3d);
        }
        
        .toolbar button.danger {
            background: linear-gradient(45deg, #ff4444, #cc0000);
        }
        
        .toolbar button.danger:hover {
            background: linear-gradient(45deg, #ff5555, #dd1111);
        }
        
        .main-container {
            display: flex;
            height: 100vh;
            padding-top: 70px;
        }
        
        .sidebar {
            width: 300px;
            background: linear-gradient(135deg, #1e1e1e, #2d2d30);
            border-right: 2px solid #0078d4;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 4px 0 12px rgba(0,0,0,0.3);
        }
        
        .code-section {
            margin-bottom: 25px;
        }
        
        .code-section h3 {
            color: #00bcf2;
            margin-bottom: 10px;
            font-size: 16px;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        
        .code-input {
            width: 100%;
            height: 150px;
            background: #0a0a0a;
            border: 2px solid #444;
            border-radius: 6px;
            color: #fff;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            padding: 10px;
            resize: vertical;
            transition: border-color 0.2s;
        }
        
        .code-input:focus {
            outline: none;
            border-color: #0078d4;
            box-shadow: 0 0 10px rgba(0, 120, 212, 0.3);
        }
        
        .canvas-area {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #363636 1px, transparent 1px);
            background-size: 25px 25px;
            overflow: hidden;
        }
        
        .node-palette {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 280px;
            background: rgba(30, 30, 30, 0.95);
            border: 2px solid #0078d4;
            border-radius: 8px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .palette-section {
            margin-bottom: 15px;
        }
        
        .palette-section h4 {
            color: #00bcf2;
            font-size: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .palette-node {
            background: linear-gradient(135deg, #404040, #505050);
            border: 2px solid #666;
            border-radius: 6px;
            padding: 8px 12px;
            margin: 5px 0;
            cursor: move;
            transition: all 0.2s;
            font-size: 11px;
            text-align: center;
            user-select: none;
        }
        
        .palette-node:hover {
            border-color: #0078d4;
            box-shadow: 0 0 15px rgba(0, 120, 212, 0.4);
            transform: translateY(-2px);
        }
        
        .palette-node.critical { border-color: #ff4444; background: linear-gradient(135deg, #4a1a1a, #5a2a2a); }
        .palette-node.work { border-color: #44ff44; background: linear-gradient(135deg, #1a4a1a, #2a5a2a); }
        .palette-node.rest { border-color: #4444ff; background: linear-gradient(135deg, #1a1a4a, #2a2a5a); }
        .palette-node.movement { border-color: #ffff44; background: linear-gradient(135deg, #4a4a1a, #5a5a2a); }
        .palette-node.management { border-color: #ff44ff; background: linear-gradient(135deg, #4a1a4a, #5a2a5a); }
        
        #blueprintCanvas {
            width: 100%;
            height: 100%;
            cursor: grab;
            display: block;
        }
        
        #blueprintCanvas:active {
            cursor: grabbing;
        }
        
        .blueprint-node {
            position: absolute;
            background: linear-gradient(135deg, #2d2d30, #404040);
            border: 2px solid #666;
            border-radius: 12px;
            min-width: 200px;
            min-height: 140px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.5);
            cursor: move;
            font-size: 12px;
            user-select: none;
            transition: all 0.2s;
        }
        
        .blueprint-node:hover {
            box-shadow: 0 8px 25px rgba(0,120,212,0.3);
        }
        
        .blueprint-node.selected {
            border-color: #0078d4;
            box-shadow: 0 0 25px rgba(0, 120, 212, 0.6);
        }
        
        .blueprint-node.critical {
            border-color: #ff4444;
            background: linear-gradient(135deg, #4a1a1a, #5a2a2a);
        }
        
        .blueprint-node.work {
            border-color: #44ff44;
            background: linear-gradient(135deg, #1a4a1a, #2a5a2a);
        }
        
        .blueprint-node.rest {
            border-color: #4444ff;
            background: linear-gradient(135deg, #1a1a4a, #2a2a5a);
        }
        
        .blueprint-node.movement {
            border-color: #ffff44;
            background: linear-gradient(135deg, #4a4a1a, #5a5a2a);
        }
        
        .blueprint-node.management {
            border-color: #ff44ff;
            background: linear-gradient(135deg, #4a1a4a, #5a2a5a);
        }
        
        .node-header {
            background: linear-gradient(90deg, #0078d4, #005a9e);
            color: white;
            padding: 10px 15px;
            border-radius: 10px 10px 0 0;
            font-weight: bold;
            font-size: 14px;
            border-bottom: 1px solid #333;
        }
        
        .node-body {
            padding: 15px;
        }
        
        .node-description {
            font-size: 11px;
            color: #ccc;
            margin-bottom: 10px;
            line-height: 1.4;
        }
        
        .node-priority {
            background: #333;
            border-radius: 12px;
            padding: 4px 10px;
            font-size: 10px;
            color: #0078d4;
            display: inline-block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        .connection-port {
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 3px solid #666;
            background: #2d2d30;
            cursor: crosshair;
            transition: all 0.2s;
        }
        
        .connection-port.input {
            left: -9px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .connection-port.output {
            right: -9px;
        }
        
        .connection-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #0078d4;
            border: 2px solid #ffffff;
            border-radius: 50%;
            cursor: move;
            z-index: 20;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .connection-handle:hover {
            background: #00bcf2;
            transform: scale(1.3);
            box-shadow: 0 4px 12px rgba(0, 120, 212, 0.5);
        }
        
        .connection-handle.selected {
            background: #ff4444;
            border-color: #ffff44;
        }
        
        .connection-line {
            stroke: #666;
            stroke-width: 3;
            fill: none;
            cursor: pointer;
            filter: drop-shadow(0 0 3px rgba(0,0,0,0.5));
        }
        
        .connection-line:hover {
            stroke-width: 4;
            filter: drop-shadow(0 0 6px rgba(0,120,212,0.3));
        }
        
        .connection-line.selected {
            stroke: #0078d4;
            stroke-width: 4;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1e1e1e, #2d2d30);
            border: 2px solid #0078d4;
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80%;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.7);
        }
        
        .modal h2 {
            color: #00bcf2;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .export-area {
            background: #0a0a0a;
            border: 2px solid #444;
            border-radius: 6px;
            padding: 20px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            margin: 20px 0;
        }
        
        .button-row {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: #1e1e1e;
            border-top: 1px solid #444;
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-size: 12px;
            color: #ccc;
            justify-content: space-between;
        }
        
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .zoom-controls button {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .zoom-controls button:hover {
            background: #555;
        }
        
        .minimap {
            position: absolute;
            bottom: 50px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid #0078d4;
            border-radius: 8px;
            overflow: hidden;
        }
        
        #minimapCanvas {
            width: 100%;
            height: 100%;
        }
        
        /* Tree View Styles */
        .tree-view-panel {
            position: fixed;
            top: 70px;
            right: -600px;
            width: 600px;
            height: calc(100vh - 100px);
            background: linear-gradient(135deg, #1e1e1e, #2d2d30);
            border-left: 3px solid #0078d4;
            box-shadow: -4px 0 12px rgba(0,0,0,0.5);
            transition: right 0.3s ease;
            z-index: 1500;
            overflow-y: auto;
            padding: 20px;
        }
        
        .tree-view-panel.open {
            right: 0;
        }
        
        .tree-view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #0078d4;
        }
        
        .tree-view-header h2 {
            color: #00bcf2;
            margin: 0;
            font-size: 18px;
        }
        
        .tree-view-close {
            background: #ff4444;
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .tree-view-close:hover {
            background: #ff5555;
        }
        
        .tree-section {
            margin-bottom: 25px;
        }
        
        .tree-section-title {
            color: #00bcf2;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            padding: 8px 12px;
            background: rgba(0, 120, 212, 0.2);
            border-radius: 6px;
            border-left: 4px solid #0078d4;
        }
        
        .tree-node {
            margin: 8px 0;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border-left: 3px solid #666;
            transition: all 0.2s;
        }
        
        .tree-node:hover {
            background: rgba(0, 120, 212, 0.15);
            border-left-color: #0078d4;
        }
        
        .tree-node.critical { border-left-color: #ff4444; }
        .tree-node.work { border-left-color: #44ff44; }
        .tree-node.rest { border-left-color: #4444ff; }
        .tree-node.movement { border-left-color: #ffff44; }
        .tree-node.management { border-left-color: #ff44ff; }
        
        .tree-node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .tree-node-name {
            font-weight: bold;
            font-size: 13px;
            color: #ffffff;
        }
        
        .tree-node-priority {
            background: rgba(0, 120, 212, 0.3);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            color: #00bcf2;
        }
        
        .tree-node-desc {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 8px;
        }
        
        .tree-transitions {
            margin-top: 8px;
            padding-left: 16px;
        }
        
        .tree-transition {
            margin: 4px 0;
            font-size: 11px;
            color: #ccc;
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }
        
        .tree-transition-arrow {
            color: #0078d4;
            font-weight: bold;
            flex-shrink: 0;
        }
        
        .tree-transition-target {
            color: #00bcf2;
            font-weight: 500;
        }
        
        .tree-transition-condition {
            color: #999;
            font-style: italic;
            margin-left: 4px;
        }
        
        .tree-stats {
            background: rgba(0, 120, 212, 0.1);
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-size: 12px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .tree-stat {
            display: flex;
            justify-content: space-between;
        }
        
        .tree-stat-label {
            color: #aaa;
        }
        
        .tree-stat-value {
            color: #00bcf2;
            font-weight: bold;
        }
        
        .tree-empty {
            text-align: center;
            padding: 40px 20px;
            color: #666;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <h1>üéÆ FSM Blueprint Editor v2.0</h1>
        <button onclick="parseCode()" class="special">üì• Parse Code</button>
        <button onclick="autoLayout()">üîß Auto Layout</button>
        <button onclick="resetView()">üéØ Reset View</button>
        <button onclick="addNewState()">‚ûï Add State</button>
        <button onclick="exportCode()">üì§ Export TypeScript</button>
        <button onclick="clearAll()" class="danger">üóëÔ∏è Clear All</button>
        <button onclick="saveProject()">üíæ Save Project</button>
        <button onclick="loadProject()">üìÅ Load Project</button>
        <button onclick="toggleTreeView()">üå≥ Tree View</button>
    </div>
    
    <div class="main-container">
        <div class="sidebar">
            <div class="code-section">
                <h3>üìù Paste Your FSM Code Here</h3>
                <textarea id="codeInput" class="code-input" placeholder="Paste your TypeScript FSM code here...

Example - Paste the entire updateColonistFSM or updateEnemyFSM function:

export function updateColonistFSM(game: any, c: Colonist, dt: number) {
  // ... initialization code ...
  
  switch (c.state) {
    case 'seekTask': {
      // Look for available work
      if (danger) changeState('flee', 'danger nearby');
      if (task) changeState('build', 'assigned build task');
      break;
    }
    case 'flee': {
      // Escape from danger
      if (!danger) changeState('seekTask', 'safe now');
      break;
    }
    // ... more states ...
  }
}

The editor will automatically extract all states and transitions!"></textarea>
                <button onclick="parseCode()" style="width: 100%; margin-top: 10px; padding: 8px;">
                    üîÑ Parse & Visualize
                </button>
            </div>
            
            <div class="code-section">
                <h3>üìã Instructions</h3>
                <div style="font-size: 11px; color: #ccc; line-height: 1.4;">
                    <p><strong>1.</strong> Copy entire updateColonistFSM or updateEnemyFSM function</p>
                    <p><strong>2.</strong> Paste it above and click "Parse & Visualize"</p>
                    <p><strong>3.</strong> Click "Auto Layout" to organize states by priority</p>
                    <p><strong>4.</strong> Click "Tree View" to see hierarchical transitions</p>
                    <p><strong>5.</strong> Drag nodes to customize layout</p>
                    <p><strong>6.</strong> Double-click connections to add bendable handles</p>
                    <p><strong>7.</strong> Export clean TypeScript documentation</p>
                    <br>
                    <p><strong>üí° Features:</strong></p>
                    <p>‚Ä¢ Parses switch-case FSM patterns automatically</p>
                    <p>‚Ä¢ Extracts all states and transitions</p>
                    <p>‚Ä¢ Works with colonist, enemy, or any FSM</p>
                    <p>‚Ä¢ Color-codes by state type (critical/work/rest/etc)</p>
                    <p>‚Ä¢ Organizes by priority (100=highest)</p>
                    <p>‚Ä¢ Tree view shows clear transition hierarchy</p>
                    <p>‚Ä¢ Save/Load projects as JSON</p>
                    <br>
                    <p><strong>üé® Keyboard Shortcuts:</strong></p>
                    <p>‚Ä¢ Ctrl+S: Save project</p>
                    <p>‚Ä¢ Ctrl+O: Load project</p>
                    <p>‚Ä¢ Ctrl+E: Export code</p>
                    <p>‚Ä¢ Delete: Remove connection handles</p>
                    <p>‚Ä¢ Esc: Cancel connection</p>
                </div>
            </div>
        </div>
        
        <div class="canvas-area">
            <canvas id="blueprintCanvas"></canvas>
            <svg id="connectionLayer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;"></svg>
            
            <div class="node-palette">
                <div class="palette-section">
                    <h4>üÜò Critical States</h4>
                    <div class="palette-node critical" draggable="true" data-type="flee">
                        <strong>Flee</strong><br>Emergency escape
                    </div>
                    <div class="palette-node critical" draggable="true" data-type="heal">
                        <strong>Heal</strong><br>Recover health
                    </div>
                </div>
                
                <div class="palette-section">
                    <h4>üî® Work States</h4>
                    <div class="palette-node work" draggable="true" data-type="build">
                        <strong>Build</strong><br>Construct buildings
                    </div>
                    <div class="palette-node work" draggable="true" data-type="work">
                        <strong>Work</strong><br>General task
                    </div>
                </div>
                
                <div class="palette-section">
                    <h4>üõå Rest States</h4>
                    <div class="palette-node rest" draggable="true" data-type="sleep">
                        <strong>Sleep</strong><br>Night rest
                    </div>
                    <div class="palette-node rest" draggable="true" data-type="eat">
                        <strong>Eat</strong><br>Consume food
                    </div>
                </div>
                
                <div class="palette-section">
                    <h4>üéØ Management</h4>
                    <div class="palette-node management" draggable="true" data-type="idle">
                        <strong>Idle</strong><br>Wait for orders
                    </div>
                </div>
            </div>
            
            <div class="minimap">
                <canvas id="minimapCanvas"></canvas>
            </div>
        </div>
    </div>
    
    <!-- Tree View Panel -->
    <div id="treeViewPanel" class="tree-view-panel">
        <div class="tree-view-header">
            <h2>üå≥ State Transition Tree</h2>
            <button class="tree-view-close" onclick="toggleTreeView()">‚úï Close</button>
        </div>
        <div id="treeViewContent">
            <div class="tree-empty">
                üì• Parse FSM code to see the state transition tree
            </div>
        </div>
    </div>
    
    <div class="status-bar">
        <div>
            <span id="statusText">Ready - Paste your FSM code and click Parse!</span>
        </div>
        <div class="zoom-controls">
            <button onclick="zoomOut()">-</button>
            <span id="zoomLevel">100%</span>
            <button onclick="zoomIn()">+</button>
        </div>
    </div>
    
    <!-- Export Modal -->
    <div id="exportModal" class="modal">
        <div class="modal-content">
            <h2>üì§ Export TypeScript Code</h2>
            <div id="exportArea" class="export-area"></div>
            <div class="button-row">
                <button onclick="copyToClipboard()">üìã Copy to Clipboard</button>
                <button onclick="downloadFile()">üíæ Download File</button>
                <button onclick="closeModal()">‚ùå Close</button>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let fsm = { nodes: {}, connections: [] };
        let camera = { x: 0, y: 0, zoom: 1 };
        let selectedNode = null;
        let selectedConnection = null;
        let selectedHandle = null;
        let isDragging = false;
        let isDraggingHandle = false;
        let dragOffset = { x: 0, y: 0 };
        let isConnecting = false;
        let connectionStart = null;
        let nextNodeId = 1;

        // Canvas setup
        const canvas = document.getElementById('blueprintCanvas');
        const ctx = canvas.getContext('2d');
        const connectionLayer = document.getElementById('connectionLayer');

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            connectionLayer.setAttribute('width', canvas.width);
            connectionLayer.setAttribute('height', canvas.height);
            render();
        }

        // Coordinate transformations
        function worldToScreen(x, y) {
            return {
                x: (x + camera.x) * camera.zoom,
                y: (y + camera.y) * camera.zoom
            };
        }

        function screenToWorld(x, y) {
            return {
                x: x / camera.zoom - camera.x,
                y: y / camera.zoom - camera.y
            };
        }

        // Code parsing function - Universal FSM parser
        function parseCode() {
            const code = document.getElementById('codeInput').value.trim();
            if (!code) {
                updateStatus('‚ö†Ô∏è Please paste some FSM code first!');
                return;
            }

            try {
                // Reset FSM
                const nodes = {};
                const connections = [];
                let nodeCounter = 0;

                // Detect FSM type and state variable pattern
                let stateVariable = 'c.state'; // Default for colonist FSM
                let switchRegex = /switch\s*\(\s*c\.state\s*\)\s*\{([\s\S]*?)(?=\n\s*\}[^}]*$)/;
                let switchMatch = code.match(switchRegex);
                
                // Try enemy FSM pattern if colonist pattern fails
                if (!switchMatch) {
                    stateVariable = 'e.state';
                    switchRegex = /switch\s*\(\s*e\.state\s*\)\s*\{([\s\S]*?)(?=\n\s*\}[^}]*$)/;
                    switchMatch = code.match(switchRegex);
                }
                
                // Try generic state pattern
                if (!switchMatch) {
                    switchRegex = /switch\s*\(\s*(\w+\.state)\s*\)\s*\{([\s\S]*?)(?=\n\s*\}[^}]*$)/;
                    switchMatch = code.match(switchRegex);
                    if (switchMatch) {
                        stateVariable = switchMatch[1];
                    }
                }
                
                if (!switchMatch) {
                    updateStatus('‚ùå Could not find switch(state) block. Make sure you pasted the updateFSM function!');
                    return;
                }

                const switchContent = switchMatch[switchMatch.length - 1]; // Get the last capture group
                
                // Extract all case statements and their content
                // This regex handles multi-line case blocks with nested braces
                const caseRegex = /case\s+['"`](\w+)['"`]\s*:\s*\{([\s\S]*?)(?=\n\s*case\s+['"`]|\n\s*default\s*:|\n\s*\}\s*$)/g;
                
                let match;
                const states = new Set();
                const transitions = [];
                const stateContents = new Map();
                
                // First pass: collect all case statements
                while ((match = caseRegex.exec(switchContent)) !== null) {
                    const stateName = match[1];
                    const caseContent = match[2];
                    states.add(stateName);
                    stateContents.set(stateName, caseContent);
                }
                
                // Second pass: find all transitions from each state
                for (const [stateName, caseContent] of stateContents.entries()) {
                    // Look for changeState calls to find transitions
                    const changeStateRegex = /changeState\s*\(\s*['"`](\w+)['"`]\s*(?:,\s*['"`]([^'"`]*)['"`])?\s*\)/g;
                    let transitionMatch;
                    
                    while ((transitionMatch = changeStateRegex.exec(caseContent)) !== null) {
                        const targetState = transitionMatch[1];
                        const condition = transitionMatch[2] || 'condition';
                        
                        states.add(targetState); // Also add target states
                        
                        // Avoid duplicate transitions
                        const exists = transitions.some(t => 
                            t.from === stateName && t.to === targetState && t.condition === condition
                        );
                        
                        if (!exists) {
                            transitions.push({
                                from: stateName,
                                to: targetState,
                                condition: condition
                            });
                        }
                    }
                    
                    // Also look for direct state assignments (e.g., c.state = 'newState')
                    const directStateRegex = new RegExp(`${stateVariable.replace('.', '\\.')}\\s*=\\s*['"\`](\\w+)['"\`]`, 'g');
                    while ((transitionMatch = directStateRegex.exec(caseContent)) !== null) {
                        const targetState = transitionMatch[1];
                        states.add(targetState);
                        
                        const exists = transitions.some(t => 
                            t.from === stateName && t.to === targetState
                        );
                        
                        if (!exists) {
                            transitions.push({
                                from: stateName,
                                to: targetState,
                                condition: 'direct assignment'
                            });
                        }
                    }
                }

                // Third pass: look for states referenced outside the switch (e.g., in initialization or global logic)
                const globalStateRegex = /['"`](\w+)['"`]\s*(?:\/\/.*state|as\s+(?:Colonist|Enemy)?State)/gi;
                while ((match = globalStateRegex.exec(code)) !== null) {
                    states.add(match[1]);
                }

                // Create nodes for all discovered states
                const stateArray = Array.from(states).sort();
                stateArray.forEach((stateName, index) => {
                    nodes[stateName] = {
                        id: stateName,
                        title: stateName.charAt(0).toUpperCase() + stateName.slice(1).replace(/([A-Z])/g, ' $1').trim(),
                        description: getStateDescription(stateName),
                        priority: getStatePriority(stateName),
                        type: getStateType(stateName),
                        position: { 
                            x: 100 + (index % 4) * 280, 
                            y: 100 + Math.floor(index / 4) * 200 
                        },
                        size: { width: 200, height: 140 },
                        conditions: {}
                    };
                });

                // Create connections and update node conditions
                transitions.forEach((trans, index) => {
                    if (nodes[trans.from] && nodes[trans.to]) {
                        // Add to node conditions
                        if (!nodes[trans.from].conditions) {
                            nodes[trans.from].conditions = {};
                        }
                        nodes[trans.from].conditions[trans.to] = trans.condition;
                        
                        // Create connection
                        connections.push({
                            id: `conn_${index}`,
                            from: trans.from,
                            to: trans.to,
                            condition: trans.condition,
                            priority: getTransitionPriority(trans.condition)
                        });
                    }
                });

                const nodeCount = Object.keys(nodes).length;
                const connCount = connections.length;
                
                if (nodeCount === 0) {
                    updateStatus('‚ùå No FSM states found. Make sure you have case statements in your switch block.');
                } else {
                    fsm = { nodes, connections };
                    render();
                    updateTreeView(); // Update tree view automatically
                    updateStatus(`‚úÖ Parsed ${nodeCount} states and ${connCount} transitions! Use Auto Layout to organize.`);
                }
                
            } catch (error) {
                updateStatus('‚ùå Error parsing code: ' + error.message);
                console.error('Parse error:', error);
            }
        }

        function getStateDescription(stateName) {
            const descriptions = {
                // Critical/Emergency states
                'flee': 'Escape from danger to safe location',
                'downed': 'Incapacitated, needs rescue',
                'drafted': 'Under player control',
                
                // Medical states
                'heal': 'Seek medical attention at infirmary',
                'doctoring': 'Treating another colonist',
                'beingTreated': 'Receiving medical treatment',
                
                // Rest & Basic Needs
                'resting': 'Recover fatigue and health inside buildings',
                'sleep': 'Sleeping in bed during night',
                'goToSleep': 'Seeking bed to sleep',
                'eat': 'Consume food to reduce hunger',
                
                // Work states
                'seekTask': 'Look for available work assignments',
                'build': 'Construct buildings and structures',
                'harvest': 'Collect crops from farms or wells',
                'chop': 'Cut down trees for wood resources',
                'mine': 'Extract stone from rock deposits',
                
                // Cooking workflow
                'cooking': 'Converting wheat into bread at oven',
                'haulBread': 'Transporting bread to storage',
                'storingBread': 'Placing bread in stockpile',
                
                // Movement & Idle
                'move': 'Navigate to target location',
                'idle': 'Wander around when no tasks available',
                'waitingAtDoor': 'Waiting for door to open',
                
                // Enemy states (if parsing enemy FSM)
                'wander': 'Random movement around area',
                'attack': 'Engaging target',
                'chase': 'Pursuing target'
            };
            return descriptions[stateName] || `${stateName} state behavior`;
        }

        function getStatePriority(stateName) {
            const priorities = {
                // Critical (90-100)
                'flee': 100,
                'drafted': 99,
                'waitingAtDoor': 98,
                'downed': 97,
                'beingTreated': 96,
                'doctoring': 95,
                
                // Medical/High Priority (80-95)
                'heal': 90,
                'sleep': 80,
                
                // Basic Needs (60-79)
                'goToSleep': 55,
                'eat': 65,
                
                // Work states (40-49)
                'storingBread': 45,
                'haulBread': 43,
                'cooking': 42,
                'build': 40,
                'chop': 40,
                'mine': 40,
                'harvest': 40,
                
                // Low priority (20-39)
                'resting': 35,
                'move': 25,
                
                // Idle states (10-19)
                'idle': 15,
                'seekTask': 10,
                'wander': 5
            };
            return priorities[stateName] || 50;
        }

        function getTransitionPriority(condition) {
            const condLower = condition.toLowerCase();
            
            // Emergency conditions
            if (condLower.includes('danger') || condLower.includes('flee')) return 100;
            if (condLower.includes('downed') || condLower.includes('unconscious')) return 97;
            if (condLower.includes('drafted') || condLower.includes('player')) return 99;
            
            // Medical conditions
            if (condLower.includes('health') || condLower.includes('heal') || condLower.includes('injur')) return 90;
            if (condLower.includes('bleed') || condLower.includes('pain')) return 92;
            
            // Basic needs
            if (condLower.includes('night') || condLower.includes('sleep')) return 80;
            if (condLower.includes('fatigue') || condLower.includes('tired') || condLower.includes('exhaust')) return 75;
            if (condLower.includes('hunger') || condLower.includes('food') || condLower.includes('starv')) return 65;
            
            // Task completion
            if (condLower.includes('complete') || condLower.includes('done') || condLower.includes('finish')) return 50;
            if (condLower.includes('arrived') || condLower.includes('reach')) return 45;
            
            // Work assignments
            if (condLower.includes('assign') || condLower.includes('task')) return 40;
            
            return 30;
        }

        function getStateType(stateName) {
            const name = stateName.toLowerCase();
            
            // Critical states (red)
            if (name.includes('flee') || name.includes('danger') || name.includes('down') || 
                name.includes('draft') || name.includes('wait') && name.includes('door')) {
                return 'critical';
            }
            
            // Work states (green)
            if (name.includes('build') || name.includes('work') || name.includes('chop') || 
                name.includes('mine') || name.includes('harvest') || name.includes('cook') ||
                name.includes('haul') || name.includes('stor')) {
                return 'work';
            }
            
            // Rest/health states (blue)
            if (name.includes('sleep') || name.includes('eat') || name.includes('rest') ||
                name.includes('heal') || name.includes('doctor') || name.includes('treat')) {
                return 'rest';
            }
            
            // Movement states (yellow)
            if (name.includes('move') || name.includes('go') || name.includes('chase') ||
                name.includes('wander')) {
                return 'movement';
            }
            
            // Management/idle states (purple)
            return 'management';
        }

        // Rendering functions
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            drawGrid();
            
            // Clear previous DOM nodes
            document.querySelectorAll('.blueprint-node').forEach(node => node.remove());
            
            // Draw nodes
            for (const node of Object.values(fsm.nodes)) {
                drawBlueprintNode(node);
            }
            
            // Draw connections
            drawConnections();
            
            // Update minimap
            updateMinimap();
        }

        function drawGrid() {
            const gridSize = 30 * camera.zoom;
            const offsetX = (camera.x * camera.zoom) % gridSize;
            const offsetY = (camera.y * camera.zoom) % gridSize;
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            for (let x = offsetX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = offsetY; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawBlueprintNode(node) {
            const screenPos = worldToScreen(node.position.x, node.position.y);
            const width = node.size.width * camera.zoom;
            const height = node.size.height * camera.zoom;
            
            // Skip if off-screen
            if (screenPos.x + width < 0 || screenPos.x > canvas.width || 
                screenPos.y + height < 0 || screenPos.y > canvas.height) {
                return;
            }

            // Create or update DOM element
            let nodeElement = document.getElementById(`node_${node.id}`);
            if (!nodeElement) {
                nodeElement = createNodeElement(node);
                canvas.parentElement.appendChild(nodeElement);
            }

            // Update position and size
            nodeElement.style.left = screenPos.x + 'px';
            nodeElement.style.top = screenPos.y + 'px';
            nodeElement.style.width = width + 'px';
            nodeElement.style.height = height + 'px';
            nodeElement.style.fontSize = Math.max(10, 12 * camera.zoom) + 'px';
        }

        function createNodeElement(node) {
            const element = document.createElement('div');
            element.id = `node_${node.id}`;
            element.className = `blueprint-node ${node.type}`;
            
            const conditionCount = Object.keys(node.conditions || {}).length;
            const outputPorts = Array.from({length: Math.max(1, conditionCount + 1)}, (_, i) => 
                `<div class="connection-port output" style="top: ${40 + i * 25}px;" data-target="${Object.keys(node.conditions || {})[i] || ''}"></div>`
            ).join('');
            
            element.innerHTML = `
                <div class="node-header">${node.title}</div>
                <div class="node-body">
                    <div class="node-priority">Priority: ${node.priority}</div>
                    <div class="node-description">${node.description}</div>
                </div>
                <div class="connection-port input"></div>
                ${outputPorts}
            `;

            // Add drag functionality
            element.addEventListener('mousedown', (e) => {
                if (e.button === 0 && !e.target.classList.contains('connection-port')) {
                    selectedNode = node.id;
                    isDragging = true;
                    const rect = element.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    
                    // Clear other selections
                    document.querySelectorAll('.blueprint-node').forEach(n => n.classList.remove('selected'));
                    element.classList.add('selected');
                    e.preventDefault();
                }
            });

            // Double-click to edit
            element.addEventListener('dblclick', () => {
                editNode(node.id);
            });

            return element;
        }

        function drawConnections() {
            connectionLayer.innerHTML = '';
            
            for (const connection of fsm.connections) {
                const fromNode = fsm.nodes[connection.from];
                const toNode = fsm.nodes[connection.to];
                
                if (!fromNode || !toNode) continue;

                const fromPos = worldToScreen(
                    fromNode.position.x + fromNode.size.width,
                    fromNode.position.y + fromNode.size.height / 2
                );
                const toPos = worldToScreen(
                    toNode.position.x,
                    toNode.position.y + toNode.size.height / 2
                );

                // Default control points or use custom handles
                let cp1x, cp1y, cp2x, cp2y;
                
                if (connection.handles) {
                    // Use custom handle positions
                    const handle1 = worldToScreen(connection.handles.cp1.x, connection.handles.cp1.y);
                    const handle2 = worldToScreen(connection.handles.cp2.x, connection.handles.cp2.y);
                    cp1x = handle1.x;
                    cp1y = handle1.y;
                    cp2x = handle2.x;
                    cp2y = handle2.y;
                } else {
                    // Default bezier curve
                    const controlOffset = Math.min(150, Math.abs(toPos.x - fromPos.x) / 2) * camera.zoom;
                    cp1x = fromPos.x + controlOffset;
                    cp1y = fromPos.y;
                    cp2x = toPos.x - controlOffset;
                    cp2y = toPos.y;
                }

                // Create SVG path with bezier curve
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const pathData = `M ${fromPos.x} ${fromPos.y} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${toPos.x} ${toPos.y}`;
                
                path.setAttribute('d', pathData);
                path.setAttribute('stroke', getPriorityColor(connection.priority));
                path.setAttribute('stroke-width', Math.max(2, 3 * camera.zoom));
                path.setAttribute('fill', 'none');
                path.setAttribute('filter', 'drop-shadow(0 0 3px rgba(0,0,0,0.5))');
                path.setAttribute('data-connection-id', connection.id);
                
                // Make connection clickable
                path.style.pointerEvents = 'stroke';
                path.style.cursor = 'pointer';
                
                // Highlight selected connection
                if (selectedConnection === connection) {
                    path.setAttribute('stroke-width', Math.max(4, 5 * camera.zoom));
                    path.setAttribute('filter', 'drop-shadow(0 0 6px rgba(76, 175, 80, 0.8))');
                }
                
                path.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectConnection(connection);
                });
                
                // Double-click to add handles
                path.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    addConnectionHandles(connection);
                });
                
                connectionLayer.appendChild(path);

                // Add condition label
                if (camera.zoom > 0.7) {
                    const midX = (fromPos.x + toPos.x) / 2;
                    const midY = (fromPos.y + toPos.y) / 2 - 15;
                    
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', midX);
                    label.setAttribute('y', midY);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('fill', '#ccc');
                    label.setAttribute('font-size', Math.max(10, 11 * camera.zoom));
                    label.setAttribute('font-family', 'Segoe UI, sans-serif');
                    label.textContent = connection.condition || 'condition';
                    label.style.pointerEvents = 'none';
                    
                    connectionLayer.appendChild(label);
                }
            }
            
            // Draw connection handles if a connection is selected
            drawConnectionHandles();
        }

        function selectConnection(connection) {
            selectedConnection = connection;
            selectedNode = null;
            selectedHandle = null;
            
            // Clear node selections
            document.querySelectorAll('.blueprint-node').forEach(n => n.classList.remove('selected'));
            
            render();
            updateStatus(`üîó Selected connection: ${connection.from} ‚Üí ${connection.to}`);
        }

        function addConnectionHandles(connection) {
            if (connection.handles) {
                updateStatus('‚ö†Ô∏è Connection already has handles! Drag them to adjust.');
                return;
            }
            
            const fromNode = fsm.nodes[connection.from];
            const toNode = fsm.nodes[connection.to];
            
            if (!fromNode || !toNode) return;

            // Calculate default handle positions
            const fromPos = {
                x: fromNode.position.x + fromNode.size.width,
                y: fromNode.position.y + fromNode.size.height / 2
            };
            const toPos = {
                x: toNode.position.x,
                y: toNode.position.y + toNode.size.height / 2
            };

            const controlOffset = Math.min(150, Math.abs(toPos.x - fromPos.x) / 2);
            
            connection.handles = {
                cp1: {
                    x: fromPos.x + controlOffset,
                    y: fromPos.y
                },
                cp2: {
                    x: toPos.x - controlOffset,
                    y: toPos.y
                }
            };
            
            selectConnection(connection);
            updateStatus(`‚ú® Added handles to connection! Drag the blue circles to bend the line.`);
        }

        function drawConnectionHandles() {
            // Remove existing handles
            document.querySelectorAll('.connection-handle').forEach(handle => handle.remove());
            
            if (!selectedConnection || !selectedConnection.handles) return;
            
            const handles = selectedConnection.handles;
            
            // Draw control point 1
            const cp1Screen = worldToScreen(handles.cp1.x, handles.cp1.y);
            const handle1 = createHandle('cp1', cp1Screen.x, cp1Screen.y);
            document.querySelector('.canvas-area').appendChild(handle1);
            
            // Draw control point 2
            const cp2Screen = worldToScreen(handles.cp2.x, handles.cp2.y);
            const handle2 = createHandle('cp2', cp2Screen.x, cp2Screen.y);
            document.querySelector('.canvas-area').appendChild(handle2);
            
            // Draw handle lines (visual guides)
            if (camera.zoom > 0.5) {
                const fromNode = fsm.nodes[selectedConnection.from];
                const toNode = fsm.nodes[selectedConnection.to];
                
                if (fromNode && toNode) {
                    const fromPos = worldToScreen(
                        fromNode.position.x + fromNode.size.width,
                        fromNode.position.y + fromNode.size.height / 2
                    );
                    const toPos = worldToScreen(
                        toNode.position.x,
                        toNode.position.y + toNode.size.height / 2
                    );
                    
                    // Guide line from start to handle 1
                    const guideLine1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    guideLine1.setAttribute('x1', fromPos.x);
                    guideLine1.setAttribute('y1', fromPos.y);
                    guideLine1.setAttribute('x2', cp1Screen.x);
                    guideLine1.setAttribute('y2', cp1Screen.y);
                    guideLine1.style.stroke = '#666';
                    guideLine1.style.strokeWidth = '1';
                    guideLine1.style.strokeDasharray = '5,5';
                    guideLine1.style.pointerEvents = 'none';
                    connectionLayer.appendChild(guideLine1);
                    
                    // Guide line from handle 2 to end
                    const guideLine2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    guideLine2.setAttribute('x1', cp2Screen.x);
                    guideLine2.setAttribute('y1', cp2Screen.y);
                    guideLine2.setAttribute('x2', toPos.x);
                    guideLine2.setAttribute('y2', toPos.y);
                    guideLine2.style.stroke = '#666';
                    guideLine2.style.strokeWidth = '1';
                    guideLine2.style.strokeDasharray = '5,5';
                    guideLine2.style.pointerEvents = 'none';
                    connectionLayer.appendChild(guideLine2);
                }
            }
        }

        function createHandle(type, x, y) {
            const handle = document.createElement('div');
            handle.className = `connection-handle ${selectedHandle === type ? 'selected' : ''}`;
            handle.style.left = (x - 6) + 'px';
            handle.style.top = (y - 6) + 'px';
            handle.dataset.handleType = type;
            
            handle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                selectedHandle = type;
                isDraggingHandle = true;
                dragOffset.x = e.clientX - x;
                dragOffset.y = e.clientY - y;
                handle.classList.add('selected');
                updateStatus(`üéØ Dragging handle ${type.toUpperCase()}...`);
            });
            
            return handle;
        }

        function getPriorityColor(priority) {
            if (priority >= 90) return '#ff4444';
            if (priority >= 70) return '#ff8844';
            if (priority >= 50) return '#ffff44';
            if (priority >= 30) return '#44ff44';
            return '#4488ff';
        }

        // Layout functions
        function autoLayout() {
            const nodesByType = {};
            const nodesByPriority = {};
            
            // Group nodes by type and priority
            for (const node of Object.values(fsm.nodes)) {
                if (!nodesByType[node.type]) nodesByType[node.type] = [];
                nodesByType[node.type].push(node);
                
                // Also group by priority ranges for better organization
                const priorityBand = Math.floor(node.priority / 20) * 20;
                if (!nodesByPriority[priorityBand]) nodesByPriority[priorityBand] = [];
                nodesByPriority[priorityBand].push(node);
            }
            
            // Sort nodes within each type by priority (high to low)
            for (const type in nodesByType) {
                nodesByType[type].sort((a, b) => b.priority - a.priority);
            }

            // Position by type in rows
            let yOffset = 50;
            const typeOrder = ['critical', 'rest', 'work', 'movement', 'management'];
            const typeLabels = {
                'critical': 'üÜò Critical',
                'rest': 'üõå Rest & Health',
                'work': 'üî® Work',
                'movement': 'üéØ Movement',
                'management': '‚öôÔ∏è Management'
            };
            
            for (const type of typeOrder) {
                if (nodesByType[type] && nodesByType[type].length > 0) {
                    const nodesInType = nodesByType[type];
                    
                    // Arrange nodes in this type horizontally
                    nodesInType.forEach((node, index) => {
                        node.position.x = 80 + index * 280;
                        node.position.y = yOffset;
                    });
                    
                    yOffset += 220; // Space between type rows
                }
            }
            
            render();
            updateStatus('üîß Auto layout applied! States organized by type and priority.');
        }

        function resetView() {
            camera = { x: 0, y: 0, zoom: 1 };
            render();
            updateZoomDisplay();
            updateStatus('üéØ View reset!');
        }

        // Export functions
        function exportCode() {
            if (Object.keys(fsm.nodes).length === 0) {
                updateStatus('‚ö†Ô∏è No FSM to export! Parse some code first.');
                return;
            }

            const code = generateTypeScriptCode();
            document.getElementById('exportArea').textContent = code;
            document.getElementById('exportModal').style.display = 'flex';
        }

        function generateTypeScriptCode() {
            let code = '// ========================================\n';
            code += '// Generated FSM Code\n';
            code += '// ========================================\n';
            code += '// Copy this back into your TypeScript file\n';
            code += `// Generated: ${new Date().toISOString()}\n`;
            code += `// States: ${Object.keys(fsm.nodes).length}\n`;
            code += `// Transitions: ${fsm.connections.length}\n\n`;
            
            // Sort states by priority
            const sortedStates = Object.entries(fsm.nodes).sort((a, b) => b[1].priority - a[1].priority);
            
            code += '// State Priority Map\n';
            code += 'function getStatePriority(state: string): number {\n';
            code += '  switch (state) {\n';
            
            for (const [nodeId, node] of sortedStates) {
                const comment = node.priority >= 90 ? ' // Critical' :
                               node.priority >= 70 ? ' // High priority' :
                               node.priority >= 50 ? ' // Medium priority' :
                               node.priority >= 30 ? ' // Work priority' :
                               ' // Low priority';
                code += `    case '${nodeId}': return ${node.priority};${comment}\n`;
            }
            
            code += '    default: return 50;\n';
            code += '  }\n';
            code += '}\n\n';
            
            // Generate state machine structure
            code += '// FSM State Machine Structure\n';
            code += 'switch (state) {\n';
            
            for (const [nodeId, node] of sortedStates) {
                code += `  case '${nodeId}': {\n`;
                code += `    // ${node.description}\n`;
                code += `    // Priority: ${node.priority} (${node.type})\n`;
                
                // Add transitions
                const transitions = fsm.connections.filter(c => c.from === nodeId);
                if (transitions.length > 0) {
                    code += `    \n`;
                    code += `    // Possible transitions:\n`;
                    for (const trans of transitions) {
                        code += `    // ‚Üí ${trans.to}: ${trans.condition}\n`;
                    }
                    code += `    \n`;
                    code += `    // TODO: Implement state logic\n`;
                    for (const trans of transitions) {
                        code += `    // if (${trans.condition}) changeState('${trans.to}', '${trans.condition}');\n`;
                    }
                }
                
                code += `    break;\n`;
                code += `  }\n\n`;
            }
            
            code += '  default: {\n';
            code += '    console.warn(`Unknown state: ${state}`);\n';
            code += '    break;\n';
            code += '  }\n';
            code += '}\n\n';
            
            // Generate state diagram documentation
            code += '// ========================================\n';
            code += '// State Diagram Overview\n';
            code += '// ========================================\n';
            code += '/*\n';
            
            for (const [nodeId, node] of sortedStates) {
                code += `\n[${nodeId.toUpperCase()}] (Priority: ${node.priority})\n`;
                code += `  Description: ${node.description}\n`;
                
                const outgoing = fsm.connections.filter(c => c.from === nodeId);
                const incoming = fsm.connections.filter(c => c.to === nodeId);
                
                if (outgoing.length > 0) {
                    code += `  Transitions to:\n`;
                    for (const trans of outgoing) {
                        code += `    ‚Üí ${trans.to} (${trans.condition})\n`;
                    }
                }
                
                if (incoming.length > 0) {
                    code += `  Can be reached from:\n`;
                    for (const trans of incoming) {
                        code += `    ‚Üê ${trans.from} (${trans.condition})\n`;
                    }
                }
            }
            
            code += '\n*/\n\n';
            code += '// Export state definitions\n';
            code += 'export const FSMStates = {\n';
            
            for (const [nodeId, node] of Object.entries(fsm.nodes)) {
                code += `  ${nodeId}: '${nodeId}',\n`;
            }
            
            code += '} as const;\n\n';
            code += 'export type FSMState = keyof typeof FSMStates;\n';
            
            return code;
        }

        function copyToClipboard() {
            const code = document.getElementById('exportArea').textContent;
            navigator.clipboard.writeText(code).then(() => {
                updateStatus('üìã Code copied to clipboard!');
            }).catch(() => {
                updateStatus('‚ùå Failed to copy to clipboard');
            });
        }

        function downloadFile() {
            const code = document.getElementById('exportArea').textContent;
            const blob = new Blob([code], { type: 'text/typescript' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'fsm-states.ts';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            updateStatus('üíæ File downloaded!');
        }

        function closeModal() {
            document.getElementById('exportModal').style.display = 'none';
        }

        // Project save/load
        function saveProject() {
            const project = {
                fsm: fsm,
                camera: camera,
                timestamp: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(project, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'fsm-project.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            updateStatus('üíæ Project saved!');
        }

        function loadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const project = JSON.parse(e.target.result);
                            fsm = project.fsm || { nodes: {}, connections: [] };
                            camera = project.camera || { x: 0, y: 0, zoom: 1 };
                            render();
                            updateZoomDisplay();
                            updateStatus('üìÅ Project loaded successfully!');
                        } catch (error) {
                            updateStatus('‚ùå Invalid project file');
                        }
                    };
                    reader.readAsText(file);
                }
            });
            input.click();
        }

        // Utility functions
        function addNewState() {
            const stateName = prompt('Enter state name:');
            if (!stateName) return;
            
            const node = {
                id: stateName,
                title: stateName.charAt(0).toUpperCase() + stateName.slice(1),
                description: `${stateName} state behavior`,
                priority: 50,
                type: 'management',
                position: { x: 100 + Object.keys(fsm.nodes).length * 50, y: 100 },
                size: { width: 200, height: 140 },
                conditions: {}
            };
            
            fsm.nodes[stateName] = node;
            render();
            updateStatus(`‚ûï Added new state: ${stateName}`);
        }

        function clearAll() {
            if (confirm('Are you sure you want to clear everything?')) {
                fsm = { nodes: {}, connections: [] };
                render();
                updateStatus('üóëÔ∏è All cleared!');
            }
        }

        function editNode(nodeId) {
            const node = fsm.nodes[nodeId];
            if (!node) return;
            
            const newTitle = prompt('Node title:', node.title);
            if (newTitle !== null) node.title = newTitle;
            
            const newPriority = prompt('Priority (0-100):', node.priority);
            if (newPriority !== null && !isNaN(newPriority)) {
                node.priority = parseInt(newPriority);
            }
            
            const newDescription = prompt('Description:', node.description);
            if (newDescription !== null) node.description = newDescription;
            
            render();
            updateStatus(`‚úèÔ∏è Edited node: ${node.title}`);
        }

        function updateStatus(message) {
            document.getElementById('statusText').textContent = message;
            console.log(message);
        }

        function zoomIn() {
            camera.zoom = Math.min(3, camera.zoom * 1.2);
            render();
            updateZoomDisplay();
        }

        function zoomOut() {
            camera.zoom = Math.max(0.3, camera.zoom * 0.8);
            render();
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = Math.round(camera.zoom * 100) + '%';
        }

        function updateMinimap() {
            // Simple minimap implementation
            const minimapCanvas = document.getElementById('minimapCanvas');
            const minimapCtx = minimapCanvas.getContext('2d');
            
            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            minimapCtx.fillStyle = '#2a2a2a';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            // Draw nodes as small rectangles
            for (const node of Object.values(fsm.nodes)) {
                const x = (node.position.x + 1000) * 0.1;
                const y = (node.position.y + 1000) * 0.1;
                
                minimapCtx.fillStyle = getPriorityColor(node.priority);
                minimapCtx.fillRect(x, y, 8, 6);
            }
        }

        // Tree View Functions
        function toggleTreeView() {
            const panel = document.getElementById('treeViewPanel');
            panel.classList.toggle('open');
            
            if (panel.classList.contains('open')) {
                updateTreeView();
            }
        }
        
        function updateTreeView() {
            const content = document.getElementById('treeViewContent');
            
            if (Object.keys(fsm.nodes).length === 0) {
                content.innerHTML = '<div class="tree-empty">üì• Parse FSM code to see the state transition tree</div>';
                return;
            }
            
            // Generate tree view HTML
            let html = '';
            
            // Add statistics
            html += '<div class="tree-stats">';
            html += '<div class="tree-stat"><span class="tree-stat-label">Total States:</span><span class="tree-stat-value">' + Object.keys(fsm.nodes).length + '</span></div>';
            html += '<div class="tree-stat"><span class="tree-stat-label">Transitions:</span><span class="tree-stat-value">' + fsm.connections.length + '</span></div>';
            
            // Count states by type
            const typeCount = {};
            for (const node of Object.values(fsm.nodes)) {
                typeCount[node.type] = (typeCount[node.type] || 0) + 1;
            }
            html += '<div class="tree-stat"><span class="tree-stat-label">Critical:</span><span class="tree-stat-value">' + (typeCount.critical || 0) + '</span></div>';
            html += '<div class="tree-stat"><span class="tree-stat-label">Work:</span><span class="tree-stat-value">' + (typeCount.work || 0) + '</span></div>';
            html += '</div>';
            
            // Group states by type and sort by priority
            const statesByType = {
                'critical': [],
                'rest': [],
                'work': [],
                'movement': [],
                'management': []
            };
            
            for (const node of Object.values(fsm.nodes)) {
                if (!statesByType[node.type]) statesByType[node.type] = [];
                statesByType[node.type].push(node);
            }
            
            // Sort each type by priority (high to low)
            for (const type in statesByType) {
                statesByType[type].sort((a, b) => b.priority - a.priority);
            }
            
            // Type labels with emojis
            const typeLabels = {
                'critical': 'üÜò Critical States',
                'rest': 'üõå Rest & Health',
                'work': 'üî® Work States',
                'movement': 'üéØ Movement',
                'management': '‚öôÔ∏è Management'
            };
            
            // Render each type section
            const typeOrder = ['critical', 'rest', 'work', 'movement', 'management'];
            for (const type of typeOrder) {
                const nodes = statesByType[type];
                if (nodes.length === 0) continue;
                
                html += '<div class="tree-section">';
                html += '<div class="tree-section-title">' + typeLabels[type] + ' (' + nodes.length + ')</div>';
                
                for (const node of nodes) {
                    html += renderTreeNode(node);
                }
                
                html += '</div>';
            }
            
            content.innerHTML = html;
        }
        
        function renderTreeNode(node) {
            let html = '<div class="tree-node ' + node.type + '">';
            
            // Header with name and priority
            html += '<div class="tree-node-header">';
            html += '<span class="tree-node-name">' + node.title + '</span>';
            html += '<span class="tree-node-priority">P' + node.priority + '</span>';
            html += '</div>';
            
            // Description
            html += '<div class="tree-node-desc">' + node.description + '</div>';
            
            // Find all transitions from this state
            const outgoing = fsm.connections.filter(c => c.from === node.id);
            const incoming = fsm.connections.filter(c => c.to === node.id);
            
            // Outgoing transitions
            if (outgoing.length > 0) {
                html += '<div class="tree-transitions">';
                html += '<div style="font-size: 10px; color: #666; margin-bottom: 4px; font-weight: bold;">TRANSITIONS TO:</div>';
                
                // Sort by priority
                outgoing.sort((a, b) => b.priority - a.priority);
                
                for (const trans of outgoing) {
                    const targetNode = fsm.nodes[trans.to];
                    if (targetNode) {
                        html += '<div class="tree-transition">';
                        html += '<span class="tree-transition-arrow">‚Üí</span>';
                        html += '<div>';
                        html += '<span class="tree-transition-target">' + targetNode.title + '</span>';
                        html += '<span class="tree-transition-condition">(' + trans.condition + ')</span>';
                        html += '</div>';
                        html += '</div>';
                    }
                }
                html += '</div>';
            }
            
            // Incoming transitions (collapsed by default, shown on hover)
            if (incoming.length > 0) {
                html += '<div class="tree-transitions" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">';
                html += '<div style="font-size: 10px; color: #666; margin-bottom: 4px; font-weight: bold;">CAN BE REACHED FROM:</div>';
                
                for (const trans of incoming) {
                    const sourceNode = fsm.nodes[trans.from];
                    if (sourceNode) {
                        html += '<div class="tree-transition" style="opacity: 0.7;">';
                        html += '<span class="tree-transition-arrow">‚Üê</span>';
                        html += '<div>';
                        html += '<span class="tree-transition-target">' + sourceNode.title + '</span>';
                        html += '<span class="tree-transition-condition">(' + trans.condition + ')</span>';
                        html += '</div>';
                        html += '</div>';
                    }
                }
                html += '</div>';
            }
            
            html += '</div>';
            return html;
        }

        // Event listeners
        isConnecting = false;
        connectionStart = null;
        let draggedPaletteNode = null;

        // Palette drag and drop functionality
        let paletteMouseDown = false;
        let paletteStartPos = { x: 0, y: 0 };
        
        document.querySelectorAll('.palette-node').forEach(node => {
            // HTML5 drag and drop (primary method)
            node.addEventListener('dragstart', (e) => {
                draggedPaletteNode = e.target.dataset.type;
                e.dataTransfer.effectAllowed = 'copy';
                e.dataTransfer.setData('text/plain', e.target.dataset.type);
                console.log('Drag started with node type:', draggedPaletteNode);
                updateStatus('üéØ Drag to canvas to create new state');
            });

            node.addEventListener('dragend', (e) => {
                console.log('Drag ended, resetting draggedPaletteNode');
                // Small delay to allow drop event to process first
                setTimeout(() => {
                    if (draggedPaletteNode) {
                        draggedPaletteNode = null;
                        updateStatus('‚ùå Node placement cancelled');
                    }
                }, 100);
            });
            
            // Manual drag fallback for cases where HTML5 drag fails
            node.addEventListener('mousedown', (e) => {
                paletteMouseDown = true;
                paletteStartPos.x = e.clientX;
                paletteStartPos.y = e.clientY;
                draggedPaletteNode = e.target.dataset.type;
                console.log('Palette mousedown:', draggedPaletteNode);
            });
        });
        
        // Global mouse events for manual drag fallback
        document.addEventListener('mousemove', (e) => {
            if (paletteMouseDown && draggedPaletteNode) {
                const deltaX = Math.abs(e.clientX - paletteStartPos.x);
                const deltaY = Math.abs(e.clientY - paletteStartPos.y);
                
                if (deltaX > 5 || deltaY > 5) {
                    // Movement threshold reached, we're dragging
                    updateStatus('üéØ Click on canvas to place the node');
                }
            }
        });
        
        document.addEventListener('mouseup', (e) => {
            if (paletteMouseDown && draggedPaletteNode) {
                paletteMouseDown = false;
                
                // Check if we're over the canvas
                const canvasRect = canvas.getBoundingClientRect();
                const isOverCanvas = (
                    e.clientX >= canvasRect.left &&
                    e.clientX <= canvasRect.right &&
                    e.clientY >= canvasRect.top &&
                    e.clientY <= canvasRect.bottom
                );
                
                if (isOverCanvas) {
                    console.log('Manual drop on canvas');
                    // Create the node manually
                    const worldPos = screenToWorld(e.clientX - canvasRect.left, e.clientY - canvasRect.top);
                    
                    const newNodeId = draggedPaletteNode + '_' + Date.now();
                    const newNode = {
                        id: newNodeId,
                        title: draggedPaletteNode.charAt(0).toUpperCase() + draggedPaletteNode.slice(1),
                        description: `${draggedPaletteNode} state behavior`,
                        priority: 50,
                        type: getStateType(draggedPaletteNode),
                        position: { x: worldPos.x, y: worldPos.y },
                        size: { width: 200, height: 140 },
                        conditions: {}
                    };
                    
                    fsm.nodes[newNodeId] = newNode;
                    render();
                    updateStatus(`‚úÖ Created new ${draggedPaletteNode} state!`);
                    console.log('Node created via manual drag');
                }
                
                draggedPaletteNode = null;
            }
        });

        // Canvas drop functionality
        // Canvas interaction events
        canvas.addEventListener('click', (e) => {
            // Don't interfere with palette node placement
            if (draggedPaletteNode) {
                return;
            }
            
            // Deselect connections and handles when clicking on empty canvas
            if (e.target === canvas) {
                selectedConnection = null;
                selectedHandle = null;
                render();
            }
        });

        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            console.log('Drop event triggered, draggedPaletteNode:', draggedPaletteNode);
            
            if (draggedPaletteNode) {
                const rect = canvas.getBoundingClientRect();
                const worldPos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
                
                const newNodeId = draggedPaletteNode + '_' + Date.now();
                const newNode = {
                    id: newNodeId,
                    title: draggedPaletteNode.charAt(0).toUpperCase() + draggedPaletteNode.slice(1),
                    description: `${draggedPaletteNode} state behavior`,
                    priority: 50,
                    type: getStateType(draggedPaletteNode),
                    position: { x: worldPos.x, y: worldPos.y },
                    size: { width: 200, height: 140 },
                    conditions: {}
                };
                
                fsm.nodes[newNodeId] = newNode;
                render();
                updateStatus(`‚úÖ Created new ${draggedPaletteNode} state!`);
                draggedPaletteNode = null;
                console.log('Node created successfully');
            }
        });

        // Connection port functionality
        function setupConnectionPorts() {
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('connection-port')) {
                    e.stopPropagation();
                    const nodeElement = e.target.closest('.blueprint-node');
                    const nodeId = nodeElement.id.replace('node_', '');
                    
                    if (e.target.classList.contains('output')) {
                        // Starting a connection
                        if (!isConnecting) {
                            isConnecting = true;
                            connectionStart = { nodeId, port: e.target };
                            e.target.style.backgroundColor = '#00ff00';
                            updateStatus('üîó Click on an input port to complete connection');
                        }
                    } else if (e.target.classList.contains('input')) {
                        // Completing a connection
                        if (isConnecting && connectionStart) {
                            const targetNodeId = nodeId;
                            const sourceNodeId = connectionStart.nodeId;
                            
                            if (sourceNodeId !== targetNodeId) {
                                // Add connection
                                if (!fsm.nodes[sourceNodeId].conditions) {
                                    fsm.nodes[sourceNodeId].conditions = {};
                                }
                                
                                const condition = prompt(`Enter condition for ${sourceNodeId} ‚Üí ${targetNodeId}:`, 'condition');
                                if (condition) {
                                    fsm.nodes[sourceNodeId].conditions[targetNodeId] = condition;
                                    
                                    // Update connections
                                    fsm.connections.push({
                                        id: `${sourceNodeId}_to_${targetNodeId}`,
                                        from: sourceNodeId,
                                        to: targetNodeId,
                                        condition: condition,
                                        priority: fsm.nodes[sourceNodeId].priority || 50
                                    });
                                    
                                    render();
                                    updateStatus(`üîó Connected ${sourceNodeId} ‚Üí ${targetNodeId}`);
                                }
                            } else {
                                updateStatus('‚ùå Cannot connect node to itself');
                            }
                            
                            // Reset connection state
                            isConnecting = false;
                            if (connectionStart.port) {
                                connectionStart.port.style.backgroundColor = '';
                            }
                            connectionStart = null;
                        }
                    }
                }
            });
        }

        canvas.addEventListener('mousemove', (e) => {
            // Don't interfere with palette dragging
            if (draggedPaletteNode || paletteMouseDown) {
                return;
            }
            
            if (isDraggingHandle && selectedConnection && selectedHandle) {
                // Drag connection handle
                const rect = canvas.getBoundingClientRect();
                const worldPos = screenToWorld(e.clientX - rect.left - dragOffset.x, e.clientY - rect.top - dragOffset.y);
                
                selectedConnection.handles[selectedHandle].x = worldPos.x;
                selectedConnection.handles[selectedHandle].y = worldPos.y;
                render();
            } else if (isDragging && selectedNode) {
                // Drag node
                const rect = canvas.getBoundingClientRect();
                const worldPos = screenToWorld(e.clientX - rect.left - dragOffset.x, e.clientY - rect.top - dragOffset.y);
                fsm.nodes[selectedNode].position.x = worldPos.x;
                fsm.nodes[selectedNode].position.y = worldPos.y;
                render();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            // Don't interfere with palette node placement
            if (draggedPaletteNode || paletteMouseDown) {
                return;
            }
            
            if (isDraggingHandle) {
                isDraggingHandle = false;
                selectedHandle = null;
                updateStatus('‚úÖ Handle position updated');
            } else {
                isDragging = false;
                selectedNode = null;
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            camera.zoom = Math.max(0.3, Math.min(3, camera.zoom * zoomFactor));
            render();
            updateZoomDisplay();
        });

        // Cancel connection on Escape and other keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isConnecting) {
                isConnecting = false;
                if (connectionStart && connectionStart.port) {
                    connectionStart.port.style.backgroundColor = '';
                }
                connectionStart = null;
                updateStatus('‚ùå Connection cancelled');
            }
            
            // Delete handles from selected connection
            if (e.key === 'Delete' && selectedConnection && selectedConnection.handles) {
                delete selectedConnection.handles;
                selectedConnection = null;
                selectedHandle = null;
                render();
                updateStatus('üóëÔ∏è Connection handles removed');
            }
            
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 's':
                        e.preventDefault();
                        saveProject();
                        break;
                    case 'o':
                        e.preventDefault();
                        loadProject();
                        break;
                    case 'e':
                        e.preventDefault();
                        exportCode();
                        break;
                }
            }
        });

        // Initialize
        window.addEventListener('load', () => {
            resizeCanvas();
            setupConnectionPorts();
            updateStatus('üéÆ FSM Blueprint Editor ready! Paste your code and click Parse.');
        });

        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
